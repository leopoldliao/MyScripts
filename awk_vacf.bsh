#!/bin/bash
# A bash script for doing autocorrelation function, need a xvg file generated by gmx traj -ov

############################################################################
#                     Author : Written by Yujie Liu                        #
#                        Email : 1051690424@qq.com                         #
#                             Version : 1.0                                #
#                           Date : 2020.05.20                              #
############################################################################

Usage() {
    echo "
    Usage: $0 Options
        -h    Show help information
        -i    Input, a xvg file generated by gmx traj -ov (default: veloc.xvg)
        -n    Value [int], the number of particle (default: 1)
        -o    Output, autocorrelation function (default: vacf.dat)
    "
}

inputfile="veloc.xvg"
fout="vacf.dat"
gnx=1

[[ $# -lt 1 ]] && { Usage; exit 1; }
options=($@); N=${#options[@]}
for((i = 0; i < N; i++)); do
    arg=${options[$i]}; j=$((i+1))
    [[ $arg =~ -h ]] && { Usage; exit 2; }
    [[ $arg =~ -i ]] && { inputfile=${options[$j]}; }
    [[ $arg =~ -n ]] && { gnx=${options[$j]}; }
    [[ $arg =~ -o ]] && { fout=${options[$j]}; }
done

awk '
    BEGIN {
        xvgfile = "'$inputfile'"; fout = "'$fout'"
        DIM = 3; XX = 0; YY = 1; ZZ = 2; 
        gnx = "'$gnx'"+0; #only one atom
        
        counter = 0;
        isfirst = 1
        while(getline < xvgfile>0) {
            if($0!~/[@#&]/ && NF > 0) {
                if(isfirst == 1) {t0 = $1+0; isfirst = 0}
                counter_dim = DIM * counter;
                for(i = 0; i < gnx; i++) {
                    c1[i, counter_dim+XX] = $(2+i*3)+0;
                    c1[i, counter_dim+YY] = $(3+i*3)+0;
                    c1[i, counter_dim+ZZ] = $(4+i*3)+0;
                }
                t1 = $1+0;
                counter++;
                #if(counter == 10000) break
            }
        }
        close(xvgfile)
        
        nout = int((counter+1)/2); nrestart = 1; bAver = "TRUE"; bNormalize = "TRUE"
        if(counter >= 4) {
            dt = (t1-t0)/(counter-1);
            do_autocorr(fout, counter, gnx, nout, c1, dt, nrestart, bAver, bNormalize)
        }
    }
    
    function do_autocorr(fn, nframes, nitem, nout, c1, dt, nrestart,
                            bAver, bNormalize) {
        printf("%10s  %10s\n", "#Time (ps)", "C(t)") > fn
        for(i = 0; i < nitem; i++) {
            do_ac_core(nframes, nout, ctmp, i, c1, nrestart);
        }
        
        if(bAver == "TRUE") {
            if(nitem > 1) {average_acf("TRUE", nframes, nitem, c1);}
            if(bNormalize == "TRUE") {normalize_acf(nout, c1);}
            sum = print_and_integrate(fn, nout, dt, c1, 1);
            printf("Correlation time (integral over corrfn): %g (ps)\n", sum);
        }
    }
    
    
    function do_ac_core(nframes, nout, corr, gp, c1, nrestart, _ARGVEND_, n) {
        if(nrestart<1) {printf("WARNING: setting number of restarts to 1\n");nrestart=1}
        for(j = 0; j < nout; j++) {
            corr[j] = 0;
        }
        
        for(j = 0; j < nframes; j += nrestart) {
            #if(j%100==0) print "DEBUG: ", j, " frame"
            j3 = DIM * j;
            
            for(k = 0; (k < nout)&&(j+k) < nframes; k++) {
                jk3 = DIM * (j+k);
                for(m = 0; m < DIM; m++) {
                    xj[m] = c1[gp, j3+m];
                    xk[m] = c1[gp, jk3+m];
                }
                ccc = iprod(xj, xk);
                corr[k] += ccc;
            }
        }
        
        for(j = 0; j < nout; j++) {
            n = (nframes-j+(nrestart-1))/nrestart;
            c1[gp, j] = corr[j]/n;
        }
    }
    
    function iprod(a, b) {
        return (a[0]*b[0]+a[1]*b[1]+a[2]*b[2]);
    }
    
    function average_acf(bVerbose, n, nitem, c1) {
        if(bVerbose == "TRUE") { printf("\nAveraging correlation functions\n");}
        for(j = 0; j < n; j++) {
            c0 = 0;
            for(i = 0; i < nitem; i++ ) { c0 += c1[i, j]; }
            c1[0, j] = c0/nitem
        }
    }
    
    function normalize_acf(nout, corr) {
        if(abs(corr[0, 0]) < 1e-5) {c0 = 0;}
        else {c0 = 1.0/corr[0, 0];}
        for(j = 0; j < nout; j++) {corr[0, j] *= c0;}
    }
    
    function print_and_integrate(fp, n, dt, c, nskip, _ARGVEND_, sum) {
        sum = 0.0
        for(j = 0; j < n; j++) {
            c0 = c[0, j];
            if (fp && (nskip == 0 || j % nskip == 0)) {
                printf("%10.3f  %10.5f\n", j*dt, c0) >> fp;
            }
            if(j > 0) {sum += dt*(c0+c[0, j-1]);}
        }
        return sum*0.5;
    }
    
    function abs(a) {
        return (a>0? a : -a)
    }
'

